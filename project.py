import os
import glob
import cv2
from nd2reader import ND2Reader
import numpy as np
from scipy import signal
import h5py
import AFT_tools as AFT
import matplotlib.pyplot as plt
from .focus_stack import FocusStacker

def fmeasure(Img): #'GRAT' Thresholded gradient (Snatos97)
    Ix= Img[:]
    Iy= Img[:]
    Iy= np.vstack((np.diff(Iy, axis=0),Img[-1]))
    Ix= np.hstack((np.diff(Ix, axis=1),Img[:,-1:]))
    FM= np.fmax(abs(Ix),abs(Iy))
    # FM= np.array([[0 if i<Th else i for i in row] for row in FM])
    FM= FM.sum()/np.count_nonzero(FM)
    return FM

# calculate coordination for each cell by import original cell img and img_seg generated by cellpose
def calcuCorr(tiff_img: np.array, seg_npy, window_size: int, overlap: int) -> int: 
    # load img and seg_mask
    img= plt.imread(tiff_img)
    cell_seg= np.load(seg_npy, allow_pickle= True)
    
    try:
        mask= np.expand_dims(cell_seg.flatten()[0]['masks'], axis= 0)
    except:
        print('cell segmentation npy file should be imported!!')

    # use AFT tools to calculate im_theta
    _, _, _, _, im_theta, _= AFT.image_local_order(img, window_size, overlap, save_path ='',
                                                    im_mask= mask, plot_overlay=False, 
                                                    plot_angles=False, plot_eccentricity=False, save_figures=False)
    
    # we tried if fibrillar features were within four-directions or adjacent 3x3 matrix could be as an output
    # method I_four-directions
    # set variable m, n to im_theta shape
    # m, n= im_theta.shape
    # create four-direction shift matrix
    # right_shift= np.hstack(([[np.nan]]* m, im_theta[:,:-1]))
    # left_shift= np.hstack((im_theta[:,1:], [[np.nan]]* m))
    # up_shift= np.vstack((im_theta[1:,:], [np.nan]* n))
    # down_shift= np.vstack(([np.nan]* n, im_theta[:-1,:]))
    # mean of cosine values of four directions matrix difference from im_theta
    # cos_mean= np.cos(im_theta- (right_shift, left_shift, up_shift, down_shift)).mean(axis=0)

    # method_II_adjacent 3x3 matrix
    # filter_kernel= np.array([[-1/8, -1/8, -1/8], [-1/8, 1, -1/8], [-1/8, -1/8, -1/8]])
    # im_filter= signal.convolve2d(im_theta, filter_kernel, mode='same')
    # cos_mean= np.nanmean(np.cos(im_filter))

    return im_theta

def calOrderParameter(im_theta_stack: np.array, neighborhood_radius: int)-> list:
    
    r= neighborhood_radius
    # check if it's a list
    if type(im_theta_stack) == np.ndarray:
        im_theta_stack = [im_theta_stack]

    # iter each im_theta in im_theta_stack
    for im_theta in im_theta_stack:
        # pad im_theta with nan value for chance that cell is close to image boundary
        im_theta_pad= np.pad(im_theta, ([r,r],[r,r]), mode='constant', constant_values=np.nan)
         
        order= AFT.calculate_order_parameter(im_theta_pad, r)
        # reshape to original (mxn) shape image
        order= np.array(order).reshape(im_theta.shape)
    
    return order

# revise original AFT functions to suit my needs:
# 1. saving figs part under def image_local_order, plt.savefig before plt.show
# 2. under calculate_order_parameter, add else: order_list.append(np.nan)
#           if not np.isnan(order_array).all() == True:
#               if order_array.size > 0:
#                   order_list.append(2 * np.nanmean(order_array))
#           else:
#               order_list.append(np.nan)



#/Users/jiaming/Desktop/Code/
#create file route
cwd='/Users/jiaming/Desktop/Code/'
os.chdir(cwd)
try:
    os.mkdir(os.path.join(cwd,'fluo_corrected'))
except FileExistsError:
    pass
files_name= glob.glob('*.nd2')
files_abbr_name= [_[:7] for _ in files_name]

# extract the fluo_reference images into np.array
c_on={}
c_on['DAPI']= np.array(cv2.imread(os.path.join(cwd,'fluo_reference','dapi.tif'),-1))
c_on['FITC']= np.array(cv2.imread(os.path.join(cwd,'fluo_reference','fitc.tif'),-1))
c_on['TxRed']= np.array(cv2.imread(os.path.join(cwd,'fluo_reference','txred.tif'),-1))
c_off= np.array(cv2.imread(os.path.join(cwd,'fluo_reference','off.tif'),-1))
c_ref= {k:(v-c_off) for k,v in c_on.items()}
c_mean= {k:v.mean() for k,v in c_ref.items()}


# iter over .nd2 files
for m in range(len(files_name)):
    img= ND2Reader(files_name[m])
    vstack= img.metadata['fields_of_view']
    zstack= img.metadata['z_levels']
    channel= img.metadata['channels']
    # iter each view 
    for j in vstack: 
        # iter each channel
        for i in range(len(channel)):
            # iter each z-level
            tmp=[]
            for k in zstack:
                
                # for epi microscopy images.
                # t_array= np.array(img.get_frame_2D(c=i,z=k,v=j))
                # t_array= (t_array-c_off)/c_ref[channel[i]]*c_mean[channel[i]]
                
                # images from epi and confocal
                t_array= t_array.astype(np.uint16)
                tmp.append(t_array)
            
            # calculate the fmeasure score
            FM_score= []
            for t in tmp:
                FM_score.append(fmeasure(t))
            best_idx= sorted(enumerate(FM_score), key= lambda x:x[1])
            tmp[0],tmp[best_idx[-1][0]]= tmp[best_idx[-1][0]],tmp[0]

            # for epi
            _tmp= FocusStacker()
            tmp_a= _tmp.focus_stack(tmp)
            
            # save as h5py file
            if i == 0:
                with h5py.File(os.path.join(cwd,'fluo_corrected',files_abbr_name[m]+'_v'+str(j+1).zfill(2)),'w') as f:
                    f.create_dataset(channel[i],data=np.array(tmp_a))
            else:
                with h5py.File(os.path.join(cwd,'fluo_corrected',files_abbr_name[m]+'_v'+str(j+1).zfill(2)),'r+') as f:
                    f.create_dataset(channel[i],data=np.array(tmp_a))    